.ss 12 0
.de BP
.IP \\fB\\$*
..
.
.ds COVESA \s-1COVESA\s0
.
.TH dltsink 1 "JAN 2026" "DLTSINK" "User Manuals"
.
.
.SH "NAME"
.
dltsink \- send DLT log messages to stdout or a log file
.
.
.SH "SYNOPSIS"
.
.B dltsink
.RB [ \-c ]
.RB [ \-e ]
.RB [ \-b ]
.RB [ \-p
.IR port ]
.RB [ \-o
.IR file ]
.I host
.
.br
.B dltsink
.B --help
.
.br
.B dltsink
.B --version
.
.
.SH "DESCRIPTION"
.
.B DLT,
.IR "\*[COVESA] Diagnostic Log and Trace" ,
is a vaguely syslog-like logging system used in cars.
.B dltsink
connects to the DLT daemon,
.BR dlt-daemon (1),
and dumps log messages to stdout or a file in a syslog-like text format,
as soon as they appear.
.PP
That is, it lets you work with DLT the way you would work with syslog,
using standard Unix tools like
.BR less (1),
.BR tail (1),
.BR grep (1)
and
.BR perl (1).
.
.PP
DLT comes with a
.BR dlt-receive (1)
utility which is similar, but that one easily loses contact with the daemon
if it restarts.
.B dltsink
tries to reconnect quickly, in order not to lose too many log messages.
.
.
.SS "Output"
.
.B dltsink
prints logs along the lines of
.IP
.ft CW
.nf
16:40:20.012  connected
16:40:21.783  APP1 CTX1 info  VELOX NEB
16:40:24.784  APP1 CTX1 warn  hungrig och avtrubbad
16:40:30.788  APP1 CTX1 info  Operating Thetan
16:40:33.794  APP1 CTX1 debug Narn bat squad
...
.fi
.PP
That is, it prints the timestamp, the application and context IDs
(padded to four letters with dashes, if necessary),
the log level and the message itself.
The message text is printed as-is, with newlines and escape sequences.
Only trailing whitespace is removed.
For brevity, the date, sequence number and time since system start
are omitted.
The ECU ID is omitted by default, but is included if the
.B \-e
option is supplied.
.PP
The timestamp records the time the message arrived to the sink, as local time.
That's why it's printed with just millisecond resolution:
the network latency and latency through dlt-daemon would make e.g. microsecond
resolution meaningless and misleading.
.
.
.SH "OPTIONS"
.
.BP \-c
Colorize the output somewhat.
.
.BP \-e
Include the ECU ID as a column in the output.
.
.BP \-b
Disable flushing.
By default,
.B dltsink
flushes output after each log line, so you can use it in pipelines and still see
each line as generated, rather than later in a big chunk.
.
.BP \-p\ \fIport
Connect to TCP port
.IR port ,
instead of the default 3490.
.
.BP \-o\ \fIfile
Write log messages to
.I file
instead of stdout.
.
.
.SH "PROTOCOL"
.
There doesn't seem to be a proper protocol definition for DLT, so
.B dltsink
is based on reverse-engineering. Here's an attempt to summarize what I learned.
.
.PP
At TCP connect,
.BR dlt-daemon (1)
begins sending a stream of messages:
.IP
.ft CW
.nf
   3d           HTYP
   0c           MCNT, serial number
   00 58        message length, including these first four bytes
   .. ..        0x54 bytes follow
.fi
.PP
And then the next message.
Clowns like these enjoy making endianness variable, the same way monkeys enjoy
throwing faeces. As you can tell from the length, this example uses big-endian.
.PP
Here's a complete log message:
.IP
.ft CW
.nf
   3d           HTYP
   0c           MCNT, serial number
   00 58        message length, from HTYP to ... 32 00
   45 43 55 31  ECU ID
   00 05 25 14  SEID, session number
   6d ec 36 34  TMSP, time since startup, unit 0.1 ms
   41           MSIN
   01           NOAR
   44 4c 54 44  APID, application ID
   49 4e 54 4d  CTID, context ID
   00 02 00
   00 38        length of 00 4e .. 20 32
   00 4e 65 77 20 63 6c 69 65 6e 74 20 63 6f 6e 6e
   65 63 74 69 6f 6e 20 23 39 20 65 73 74 61 62 6c
   69 73 68 65 64 2c 20 54 6f 74 61 6c 20 43 6c 69
   65 6e 74 73 20 3a 20 32
   00
.fi
.PP
HTYP is a set of flags:
bit\ 0: has extended header;
bit\ 1: big endian;
bit\ 2: has ECU ID;
bit\ 3: has SEID;
bit\ 4: has timestamp;
bits\ 5\-7: protocol version.
Thus 3d means all flags enabled (except, oddly, big endian),
and protocol version 1.
.PP
MSIN is, similarly
bit\ 0: verbose (whatever that means);
bits\ 1\-3: message type
log\ (0),
trace\ (1),
network trace\ (2),
control\ (3).
The 4MSB are, for log messages, the level:
fatal\ (1),
error\ (2),
warn\ (3),
info\ (4),
debug\ (5),
verbose\ (6).
.PP
There appears to be no way to get a real timestamp for the log
messages. The existing timestamps are relative to system startup, with
no portable way to find out when that happened.
Also, it's unclear if this relative timestamp is added at the source, or in
.B dlt-daemon
when it happens to find the time to process the message.
.
.
.SH "NOTES"
.
"Those who do not understand Unix are condemned to reinvent it, poorly."
.br
\[em] Henry Spencer
.
.
.SH "BUGS"
.
.B dltsink
could be more aggressive about connecting and disconnecting. For
example, a dead TCP connection won't be detected quickly, since
dltsink doesn't send any application-level probes (and I don't know
whether the protocol would support doing that).
.PP
As noted above, log messages don't have proper timestamps. The time
logged is when
.B dltsink
reads the message.
This is also how the \*[COVESA] tools do it.
It would be possible to improve on this, by measuring the smallest distance
between the message and retrieval timestamps, while watching out for wraparound.
.PP
The protocol is not documented, and the implementation here is na\(:ive.
.
.
.SH "AUTHOR"
.
J\(:orgen Grahn \[fo]grahn@snipabacken.se\[fc].
.
.
.SH "LICENSE"
.
The GNU General Public License (GPL) version 2 or (at your option) version 3.
.
.
.SH "SEE ALSO"
.
.BR dlt-daemon (1),
.BR dlt-receive (1),
.BR rsyslogd (8).
.PP
\[fo]https://github.com/COVESA/dlt-daemon\[fc].
